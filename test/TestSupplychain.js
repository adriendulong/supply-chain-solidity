const truffleAssert = require('truffle-assertions');

let SupplyChain = artifacts.require('SupplyChain')
const BN = web3.utils.BN;

contract('SupplyChain', accounts => {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    let sku = 1
    let upc = 1
    const ownerID = accounts[0]
    const originWinemakerID = accounts[1]
    const originWinemakerName = "Clos Systey"
    const originWinemakerInformation = "Yarray Valley"
    const originWinemakerLatitude = "-38.239770"
    const originWinemakerLongitude = "144.341490"
    let productID = sku + upc
    const productNotes = "Best beans for Espresso"
    const productPrice = web3.utils.toWei("1", "ether")
    let wineState = 0
    const wineMerchantID = accounts[2]
    const consumerID = accounts[3]
    const emptyAddress = '0x00000000000000000000000000000000000000'

    console.log("ganache-cli accounts used here...")
    console.log("Contract Owner: accounts[0] ", accounts[0])
    console.log("Winemaker: accounts[1] ", accounts[1])
    console.log("WineMerchant: accounts[2] ", accounts[2])
    console.log("Consumer: accounts[4] ", accounts[4])

    before(async() => {
        // Grant each address with the right role
        const supplyChain = await SupplyChain.deployed()
        await supplyChain.addWinemaker(originWinemakerID);
        await supplyChain.addWineMerchant(wineMerchantID);
        await supplyChain.addConsumer(consumerID);
    });

    // FAIL TEST FUNCTION
    // Pause the contract and check we are not able to do something
    it("Check that we are not able to make a new wine when the contract is paused", async() => {
        const supplyChain = await SupplyChain.deployed();

        // Pause the contract
        await supplyChain.pause({from: ownerID});
        
        // Check that we are not able to create a new wine when the contract is paused
        await truffleAssert.fails(
            supplyChain.makeWine(upc, originWinemakerName, originWinemakerInformation, originWinemakerLatitude, originWinemakerLongitude, productNotes, {from: originWinemakerID}),
            truffleAssert.ErrorType.REVERT,
            "Pausable::whenNotPaused - The contract is paused, impossible to perform this action right now"
        );

        // Unpause the contract
        await supplyChain.unpause({from: ownerID});

    }) 

    
    // 1st Test
    it("Testing smart contract function makeWine() that allows a winemaker to make a wine", async() => {
        const supplyChain = await SupplyChain.deployed()



        // Mark an item as Harvested by calling function harvestItem()
        let result = await supplyChain.makeWine(upc, originWinemakerName, originWinemakerInformation, originWinemakerLatitude, originWinemakerLongitude, productNotes, {from: originWinemakerID});

        // Check that the 'Made' event has been emitted
        truffleAssert.eventEmitted(result, 'Made');

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchWineBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchWineBufferTwo.call(upc)

        
        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originWinemakerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], originWinemakerID, 'Error: Missing or Invalid originWinemakerID')
        assert.equal(resultBufferOne[4], originWinemakerName, 'Error: Missing or Invalid originWinemakerName')
        assert.equal(resultBufferOne[5], originWinemakerInformation, 'Error: Missing or Invalid originWinemakerInformation')
        assert.equal(resultBufferOne[6], originWinemakerLatitude, 'Error: Missing or Invalid originWinemakerLatitude')
        assert.equal(resultBufferOne[7], originWinemakerLongitude, 'Error: Missing or Invalid originWinemakerLongitude')
        assert.equal(resultBufferTwo.wineState, 0, 'Error: Invalid item State')      
    }) 
    
    // FAIL TEST FUNCTION
    it("Check that the function makeWine() fails when call by a user who is not a winemaker", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        await truffleAssert.fails(
            supplyChain.makeWine(upc, originWinemakerName, originWinemakerInformation, originWinemakerLatitude, originWinemakerLongitude, productNotes, {from: consumerID}),
            truffleAssert.ErrorType.REVERT,
            "WinemakerRole::onlyWinemaker - You need the winemaker role to do this action"
        );
    })    

    // 2nd Test
    it("Testing smart contract function ageWine() that allows a winemaker to age wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        const monthsAged = 12;
        
        let result = await supplyChain.ageWine(upc, monthsAged, {from: accounts[1]});
        
        // Watch the emitted event Aged
        truffleAssert.eventEmitted(result, 'Aged');

        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 1, 'Error: Missing or Invalid state');
        assert.equal(resultFetch.monthsAged.toNumber(), monthsAged, 'Error: Missing or Invalid months aged value');
        
    })    

    // 3rd Test
    it("Testing smart contract function bottleWine() that allows a winemaker to bottle wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        let result = await supplyChain.bottleWine(upc, {from: accounts[1]});
        
        // Watch the emitted event Bottled
        truffleAssert.eventEmitted(result, 'Bottled');

        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 2, 'Error: Missing or Invalid state');
        
    })    

    // 4th Test
    it("Testing smart contract function packWine() that allows a winemaker to pack the wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        let result = await supplyChain.packWine(upc, {from: accounts[1]});
        
        // Watch the emitted event Packed
        truffleAssert.eventEmitted(result, 'Packed');

        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 3, 'Error: Missing or Invalid state');
          
    })    

    // 5th Test
    it("Testing smart contract function sellWine() that allows a winemaker to sell its wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        const price = web3.utils.toWei("1", "ether");
        
        let result = await supplyChain.sellWine(upc, price, {from: accounts[1]});
        
        // Watch the emitted event ForSale
        truffleAssert.eventEmitted(result, 'ForSale');

        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 4, 'Error: Missing or Invalid state');
        assert.equal(resultFetch.productPrice.toString(), price, 'Error: Missing or Invalid price');
        
    }) 

    // FAIL TEST FUNCTION
    it("Check that we are not able to buy the wine if not enough fund", async() => {
        const supplyChain = await SupplyChain.deployed();

        const amount = web3.utils.toWei("0.1", "ether");
        
        await truffleAssert.fails(
            supplyChain.buyWine(upc, {from: wineMerchantID, value: amount}),
            truffleAssert.ErrorType.REVERT,
            "SupplyChain::paidEnough - Not enough fund"
        );
    }) 
    
    // 6th Test
    it("Testing smart contract function buyWine() that allows a wine marchant to buy the wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        // Set an amount above to get the change
        const amount = web3.utils.toWei("2", "ether");

        // We will help us to check if the balance of the winemaker after the deal equal is previous balance plus the price of the wine (1 ether)
        const price = web3.utils.toWei("1", "ether");
        const winemakerBalanceBefore = await web3.eth.getBalance(accounts[1]);
        const awaitedWinemakerBalance = new BN(winemakerBalanceBefore).add(new BN(price)).toString();
        
        let result = await supplyChain.buyWine(upc, {from: wineMerchantID, value: amount});
        
        // Watch the emitted event Sold
        truffleAssert.eventEmitted(result, 'Sold');

        const resultFetchOne = await supplyChain.fetchWineBufferOne(upc);
        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        const winemakerBalanceAfter = await web3.eth.getBalance(accounts[1]);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 5, 'Error: Missing or Invalid state');
        assert.equal(resultFetch.wineMerchantID, accounts[2], 'Error: Missing or Invalid wineMerchantID');
        assert.equal(resultFetchOne.ownerID, accounts[2], 'Error: Missing or Invalid ownerID');
        assert.equal(winemakerBalanceAfter, awaitedWinemakerBalance, 'Error: Invalid winemaker balance after the deal');
        
    }) 

     // 7th Test
     it("Testing smart contract function shipWine() that allows a winemaker to ship the wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        let result = await supplyChain.shipWine(upc, {from: accounts[1]});
        
        // Watch the emitted event Shipped
        truffleAssert.eventEmitted(result, 'Shipped');

        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 6, 'Error: Missing or Invalid state');
          
    }) 
    
     // 8th Test
     it("Testing smart contract function receiveWine() that allows a wine merchant to set a wine as received", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        let result = await supplyChain.receiveWine(upc, {from: accounts[2]});
        
        // Watch the emitted event Received
        truffleAssert.eventEmitted(result, 'Received');

        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 7, 'Error: Missing or Invalid state');
          
    }) 

    // FAIL TEST FUNCTION
    it("Check that we are not able to purchase the wine if it is not available for purchase", async() => {
        const supplyChain = await SupplyChain.deployed();

        const amount = web3.utils.toWei("0.1", "ether");
        
        await truffleAssert.fails(
            supplyChain.purchaseWine(upc, {from: consumerID, value: amount}),
            truffleAssert.ErrorType.REVERT,
            "SupplyChain::forPurchase - this wine has not the ForPurchase state"
        );
    })

    // 9th Test
    it("Testing smart contract function setOnPurchaseWine() that allows a wine merchant to set a wine ForPurchase", async() => {
        const supplyChain = await SupplyChain.deployed()
        const price = web3.utils.toWei("2", "ether");
        
        let result = await supplyChain.setOnPurchaseWine(upc, price, {from: accounts[2]});
        
        // Watch the emitted event ForPurchase
        truffleAssert.eventEmitted(result, 'ForPurchase');

        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 8, 'Error: Missing or Invalid state');
        assert.equal(resultFetch.productFinalPrice.toString(), price, 'Error: Missing or Invalid productFinalPrice');
        
    }) 

     // FAIL TEST FUNCTION
     it("Check that we are not able to purchase the wine if not enough fund", async() => {
        const supplyChain = await SupplyChain.deployed();

        const amount = web3.utils.toWei("0.1", "ether");
        
        await truffleAssert.fails(
            supplyChain.purchaseWine(upc, {from: consumerID, value: amount}),
            truffleAssert.ErrorType.REVERT,
            "SupplyChain::paidEnough - Not enough fund"
        );
    }) 

    // 10th Test
    it("Testing smart contract function purchaseWine() that allows a consumer to purchase the wine", async() => {
        const supplyChain = await SupplyChain.deployed()
        const amount = web3.utils.toWei("2", "ether");

        // We will help us to check if the balance of the winemaker after the deal equal is previous balance plus the price of the wine (1 ether)
        const price = web3.utils.toWei("2", "ether");
        const wineMerchantBalanceBefore = await web3.eth.getBalance(wineMerchantID);
        const awaitedWineMerchantBalance = new BN(wineMerchantBalanceBefore).add(new BN(price)).toString();
        
        let result = await supplyChain.purchaseWine(upc, {from: accounts[3], value: amount});
        
        // Watch the emitted event Purchased
        truffleAssert.eventEmitted(result, 'Purchased');

        const resultFetchOne = await supplyChain.fetchWineBufferOne(upc);
        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        const wineMerchantBalanceAfter = await web3.eth.getBalance(wineMerchantID);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 9, 'Error: Missing or Invalid state');
        assert.equal(resultFetchOne.ownerID, consumerID, 'Error: Missing or Invalid ownerID');
        assert.equal(resultFetch.consumerID, consumerID, 'Error: Missing or Invalid consumerID');
        assert.equal(wineMerchantBalanceAfter, awaitedWineMerchantBalance, 'Error: Invalid wine merchant balance after the deal');
        
    }) 

    // 11th Test
    it("Testing smart contract function drinkWine() that allows a consumer to drink the wine he bought", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        let result = await supplyChain.drinkWine(upc, {from: consumerID});
        
        // Watch the emitted event Drunk
        truffleAssert.eventEmitted(result, 'Drunk');

        const resultFetch = await supplyChain.fetchWineBufferTwo(upc);

        // Verify the result set
        assert.equal(resultFetch.wineSKU.toNumber(), sku, 'Error: Invalid item SKU')
        assert.equal(resultFetch.wineUPC.toNumber(), upc, 'Error: Invalid item UPC')
        assert.equal(resultFetch.wineState.toNumber(), 10, 'Error: Missing or Invalid state');
          
    }) 
});

